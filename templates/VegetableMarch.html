<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>VegetableMarch</title>
    <style>
      #canvas {
        width: 800px;
        height: 600px;
        touch-action: none;
      }
      #START {
        position: absolute;
        left: 200px;
        top: 200px;
      }
    </style>
    <script>
      "use strict";

      let ctx; // 描画コンテキスト
      let engine; // 物理エンジン
      let veges = []; // 野菜を格納する配列
      let timer = NaN; // タイマー
      let startTime = NaN; //  ゲーム開始時刻
      let elapsed = 0; // 経過時間
      let score = 0; // スコア
      let walls = [
        [-60, -100, 100, 800],
        [500, -100, 100, 800],
        [-60, 520, 700, 100],
      ]; // 壁（左右底）のx, y, w, h座標
      let images = []; // 野菜の画像を格納する配列


      let BodyStatic = 1;
      let BodyDynamic = 2;
      let ShapeCircle = 3;
      let ShapeRectangle = 4;
      let ShapeLine = 5;

      function rand(v) {
        return Math.floor(Math.random() * v);
      }

      // エンジン初期化 & Canvas初期化
      function init() {
        let canvas = document.getElementById("canvas");
        ctx = canvas.getContext("2d");
        ctx.font = "20pt Arial";
        ctx.strokeStyle = "blue";
        ctx.lineWidth = 5;
        ctx.textAlign = "center";

        engine = new Engine(-100, -100, 700, 700, 0, 9.8);

        // 壁
        walls.forEach(function (w) {
          let r = new RectangleEntity(w[0], w[1], w[2], w[3]);
          r.color = "gray";
          engine.entities.push(r);
        });

        // 野菜
        for (let i = 0; i < 7; i++) {
          for (let j = 0; j < 10; j++) {
            let x = i * 60 + 75 + rand(5);
            let y = j * 50 + 50 + rand(5);
            let r = new CircleEntity(x, y, 25, BodyDynamic, 1, 0.98);
            r.color = rand(5);
            engine.entities.push(r);
          }
        }

        for (let i = 0; i < 5; i++) {
          images.push(document.getElementById("fruit" + i)); // 野菜画像を配列に格納
        }

        repaint();
      }

      function go() {
        // キャンバスにイベントハンドラ登録
        let canvas = document.getElementById("canvas");
        canvas.onmousedown = mymousedown;
        canvas.onmousemove = mymousemove;
        canvas.onmouseup = mymouseup;
        canvas.addEventListener("touchstart", mymousedown);
        canvas.addEventListener("touchmove", mymousemove);
        canvas.addEventListener("touchend", mymouseup);

        document.body.addEventListener(
          "touchmove",
          function (event) {
            event.preventDefault();
          },
          false
        );  // タッチ時のコンテキストメニュー非表示に
        document.getElementById("START").style.display = "none";
        document.getElementById("bgm").play();

        startTime = new Date();
        timer = setInterval(tick, 50);
      }

      // メインループ
      function tick() {
        engine.step(0.01); // 物理エンジンの時刻を進める

        elapsed = (new Date().getTime() - startTime) / 1000;
        if (elapsed > 57) {
          clearInterval(timer); // 57秒でタイムアップ
          timer = NaN;
        }
        repaint(); // 再描画
      }

      // マウス押下時の処理
      function mymousedown(evt) {
        let x = !isNaN(evt.offsetX) ? evt.offsetX : evt.touches[0].clientX; // マウス押下x座標
        let y = !isNaN(evt.offsetY) ? evt.offsetY : evt.touches[0].clientY; // マウス押下y座標
        engine.entities.forEach(function (e) {
          if (e.isHit(x, y) && e.shape == ShapeCircle) {
            veges.push(e); // 円が選択されたら、野菜とみなして配列vegesに追加
            e.selected = true;
          }
        });
      }

      // マウス移動時の処理
      function mymousemove(evt) {
        if (veges.length == 0) {
          return;
        }

        let x = !isNaN(evt.offsetX) ? evt.offsetX : evt.touches[0].clientX;
        let y = !isNaN(evt.offsetY) ? evt.offsetY : evt.touches[0].clientY;
        let p = veges[veges.length - 1];  // リストの最後の野菜を取得

        engine.entities.forEach(function (e) {
          if (e.isHit(x, y) && e.shape == ShapeCircle) {
            if (veges.indexOf(e) < 0 && e.color == p.color) {
              let d2 = Math.pow(e.x - p.x, 2) + Math.pow(e.y - p.y, 2); // 最後の野菜との距離
              if (d2 < 4000) {
                veges.push(e);  // 距離が4000未満であれば連結→リストに追加して、野菜を選択状態に
                e.selected = true;
              }
            }
          }
        });
      }

      // マウスリリース時の処理
      function mymouseup(evt) {
        if (veges.length > 1) {
          engine.entities = engine.entities.filter(function (e) {
            return e.selected != true;  // 非選択状態の野菜だけをフィルタ（＝選択状態の野菜を削除）
          });

          // 消去分を追加
          for (let i = 0; i < veges.length; i++) {
            let x = 75 + rand(350);
            let r = new CircleEntity(x, 0, 25, BodyDynamic, 1, 0.98);
            r.color = rand(5);
            engine.entities.push(r);
          }
          score += veges.length * 100;
        }
        veges.forEach(function (e) {
          delete e.selected;
        });
        veges = [];
      }

      function repaint() {
        // 背景クリア
        ctx.drawImage(fruitbg, 0, 0);

        // 野菜を描画
        for (let i = 0; i < engine.entities.length; i++) {
          let e = engine.entities[i];
          let img = images[e.color];
          if (e.shape == ShapeCircle) {
            ctx.drawImage(img, e.x - 28, e.y - 28, 62, 62);
            if (e.selected) {
              ctx.strokeStyle = "yellow";
              ctx.beginPath();
              ctx.arc(e.x, e.y, e.radius, 0, Math.PI * 2);
              ctx.closePath();
              ctx.stroke();
            }
          }
        }

        // 線
        if (veges.length > 0) {
          ctx.strokeStyle = "#B1EB22";
          ctx.beginPath();
          ctx.moveTo(veges[0].x, veges[0].y);
          for (let i = 1; i < veges.length; i++) {
            ctx.lineTo(veges[i].x, veges[i].y);
          }
          ctx.stroke();
        }

        // メッセージ
        ctx.save();
        ctx.fillStyle = "#F9D79F";
        ctx.font = "bold 24pt sans-serif";
        ctx.font;
        ctx.translate(650, 442);
        ctx.rotate(-0.05);
        ctx.fillText(isNaN(timer) ? "FINISH" : "Score", 0, 0);
        ctx.restore();

        // スコア
        ctx.save();
        ctx.font = "bold 32pt sans-serif";
        ctx.translate(650, 365);
        ctx.rotate(0.08);
        ctx.fillStyle = "#F9D79F";
        ctx.fillText(("0000000" + score).slice(-7), 0, 0);
        ctx.restore();

        // 残り時間
        ctx.save();
        ctx.fillStyle = "rgba(215, 130, 40, 0.5)";
        ctx.beginPath();
        ctx.moveTo(656, 153);
        ctx.arc(
          656,
          153,
          88,
          -Math.PI / 2,
          (elapsed / 57) * Math.PI * 2 - Math.PI / 2
        );
        ctx.closePath();
        ctx.fill();
        ctx.restore();
      }



      function Vec(x, y) {
          this.x = x;
          this.y = y;
      }

      Vec.prototype.add = function (v) {      // 加算
          return new Vec(this.x + v.x, this.y + v.y);
      }

      Vec.prototype.mul = function (x, y) {   // 掛算
          let r = y || x;
          return new Vec(this.x * r, this.y * r);
      }

      Vec.prototype.dot = function (v) {      // 内積
          return this.x * v.x + this.y * v.y;
      }

      Vec.prototype.cross = function (v) {    // 外積
          return this.x * v.y - v.x * this.y;
      }

      Vec.prototype.move = function (dx, dy) {// 自分を移動
          this.x += dx;
          this.y += dy;
      }

      // 矩形オブジェクト
      function RectangleEntity(x, y, width, height) {
          this.shape = ShapeRectangle;
          this.type = BodyStatic;
          this.x = x;
          this.y = y;
          this.w = width;
          this.h = height;
          this.deceleration = 1.0;
          this.isHit = function (i, j) {
              return (this.x <= i && i <= this.x + this.w &&
                  this.y <= j && j <= this.y + this.h)
          }
      }

      // 線オブジェクト
      function LineEntity(x0, y0, x1, y1, restitution) {
          this.shape = ShapeLine;
          this.type = BodyStatic;
          this.x = (x0 + x1) / 2;
          this.y = (y0 + y1) / 2;
          this.x0 = x0;
          this.y0 = y0;
          this.x1 = x1;
          this.y1 = y1;

          this.restitution = restitution || 0.9;
          this.vec = new Vec(x1 - x0, y1 - y0);
          let length = Math.sqrt(Math.pow(this.vec.x, 2) + Math.pow(this.vec.y, 2));
          this.norm = new Vec(y0 - y1, x1 - x0).mul(1 / length);
      }

      // 円オブジェクト
      function CircleEntity(x, y, radius, type, restitution, deceleration) {
          this.shape = ShapeCircle;
          this.type = type || BodyDynamic;
          this.x = x;
          this.y = y;
          this.radius = radius;
          this.restitution = restitution || 0.9;
          this.deceleration = deceleration || 1.0;
          this.accel = new Vec(0, 0);
          this.velocity = new Vec(0, 0);

          this.move = function (dx, dy) { // 円を移動
              this.x += dx;
              this.y += dy;
          }

          this.isHit = function (x, y) {
              let d2 = Math.pow(x - this.x, 2) + Math.pow(y - this.y, 2);
              return d2 < Math.pow(this.radius, 2);
          }

          this.collidedWithRect = function (r) {  // 円と矩形の衝突
              // 矩形の４辺上で最も円に近い座標(nx, ny)を求める
              let nx = Math.max(r.x, Math.min(this.x, r.x + r.w));
              let ny = Math.max(r.y, Math.min(this.y, r.y + r.h));
              
              if (!this.isHit(nx, ny)) {      // 衝突なし→リターン
                  return;
              }

              if (this.onhit) {               // 衝突時のコールバック
                  this.onhit(this, r);
              }

              let d2 = Math.pow(nx - this.x, 2) + Math.pow(ny - this.y, 2);
              let overlap = Math.abs(this.radius - Math.sqrt(d2));
              let mx = 0, my = 0;

              if (ny == r.y) {		        // 上辺衝突
                  my = -overlap;
              } else if (ny == r.y + r.h) {	// 下辺衝突
                  my = overlap;
              } else if (nx == r.x) {         // 左辺衝突
                  mx = -overlap;
              } else if (nx == r.x + r.w) {   // 右辺衝突
                  mx = overlap;
              } else {    // 矩形の中
                  mx = -this.velocity.x;
                  my = -this.velocity.y;
              }

              this.move(mx, my);
              if (mx) {   // X軸方向へ反転
                  this.velocity = this.velocity.mul(-1 * this.restitution, 1);
              }
              if (my) {   // Y軸方向へ反転
                  this.velocity = this.velocity.mul(1, -1 * this.restitution);
              }
          }

          this.collidedWithLine = function (line) {  // 円と線の衝突
              let v0 = new Vec(line.x0 - this.x + this.velocity.x, line.y0 - this.y + this.velocity.y);
              let v1 = this.velocity;
              let v2 = new Vec(line.x1 - line.x0, line.y1 - line.y0);
              let cv1v2 = v1.cross(v2);
              let t1 = v0.cross(v1) / cv1v2;
              let t2 = v0.cross(v2) / cv1v2;
              let crossed = (0 <= t1 && t1 <= 1) && (0 <= t2 && t2 <= 1);

              if (crossed) {
                  this.move(-this.velocity.x, -this.velocity.y);
                  let dot0 = this.velocity.dot(line.norm);   // 法線と速度の内積
                  let vec0 = line.norm.mul(-2 * dot0);
                  this.velocity = vec0.add(this.velocity);
                  this.velocity = this.velocity.mul(line.restitution * this.restitution);
              }
          }

          this.collidedWithCircle = function (peer) {  // 円と円の衝突
              let d2 = Math.pow(peer.x - this.x, 2) + Math.pow(peer.y - this.y, 2);
              if (d2 >= Math.pow(this.radius + peer.radius, 2)) {
                  return;
              }

              if (this.onhit) {
                  this.onhit(this, peer);
              }
              if (peer.onhit) {
                  peer.onhit(peer, this);
              }

              let distance = Math.sqrt(d2) || 0.01;
              let overlap = this.radius + peer.radius - distance;

              let v = new Vec(this.x - peer.x, this.y - peer.y);
              let aNormUnit = v.mul(1 / distance);        // 法線単位ベクトル１
              let bNormUnit = aNormUnit.mul(-1);          // 法線単位ベクトル２

              
              if (this.type == BodyDynamic && peer.type == BodyStatic) {
                  this.move(aNormUnit.x * overlap, aNormUnit.y * overlap);
                  let dot0 = this.velocity.dot(aNormUnit);   // 法線と速度の内積
                  let vec0 = aNormUnit.mul(-2 * dot0);
                  this.velocity = vec0.add(this.velocity);
                  this.velocity = this.velocity.mul(this.restitution);
              }
              else if (peer.type == BodyDynamic && this.type == BodyStatic) {
                  peer.move(bNormUnit.x * overlap, bNormUnit.y * overlap);
                  let dot1 = peer.velocity.dot(bNormUnit);   // 法線と速度の内積
                  let vec1 = bNormUnit.mul(-2 * dot1);
                  peer.velocity = vec1.add(peer.velocity);
                  peer.velocity = peer.velocity.mul(peer.restitution);
              }
              else {
                  this.move(aNormUnit.x * overlap / 2, aNormUnit.y * overlap / 2);
                  peer.move(bNormUnit.x * overlap / 2, bNormUnit.y * overlap / 2);

                  let aTangUnit = new Vec(aNormUnit.y * -1, aNormUnit.x); // 接線ベクトル１
                  let bTangUnit = new Vec(bNormUnit.y * -1, bNormUnit.x); // 接線ベクトル２

                  let aNorm = aNormUnit.mul(aNormUnit.dot(this.velocity)); // aベクトル法線成分
                  let aTang = aTangUnit.mul(aTangUnit.dot(this.velocity)); // aベクトル接線成分
                  let bNorm = bNormUnit.mul(bNormUnit.dot(peer.velocity)); // bベクトル法線成分
                  let bTang = bTangUnit.mul(bTangUnit.dot(peer.velocity)); // bベクトル接線成分

                  this.velocity = new Vec(bNorm.x + aTang.x, bNorm.y + aTang.y);
                  peer.velocity = new Vec(aNorm.x + bTang.x, aNorm.y + bTang.y);
              }
          }
      }

      // 物理エンジン
      function Engine(x, y, width, height, gravityX, gravityY) {
          this.worldX = x || 0;
          this.worldY = y || 0;
          this.worldW = width || 1000;
          this.worldH = height || 1000;
          this.gravity = new Vec(gravityX, gravityY);
          this.entities = [];

          this.setGravity = function (x, y) {
              this.gravity.x = x;
              this.gravity.y = y;
          }

          this.step = function (elapsed) {
              let gravity = this.gravity.mul(elapsed, elapsed);
              let entities = this.entities;

              // entityを移動
              entities.forEach(function (e) {
                  if (e.type == BodyDynamic) {
                      let accel = e.accel.mul(elapsed, elapsed);
                      e.velocity = e.velocity.add(gravity);
                      e.velocity = e.velocity.add(accel);
                      e.velocity = e.velocity.mul(e.deceleration);
                      e.move(e.velocity.x, e.velocity.y);
                  }
              });

              // 範囲外のオブジェクトを削除
              this.entities = entities.filter(function (e) {
                  return this.worldX <= e.x && e.x <= this.worldX + this.worldW &&
                      this.worldY <= e.y && e.y <= this.worldY + this.worldH;
              }, this);

              // 衝突判定 & 衝突処理
              for (let i = 0 ; i < entities.length - 1 ; i++) {
                  for (let j = i + 1; j < entities.length ; j++) {
                      let e0 = entities[i], e1 = entities[j];
                      if (e0.type == BodyStatic && e1.type == BodyStatic) {
                          continue;
                      }

                      if (e0.shape == ShapeCircle && e1.shape == ShapeCircle) {
                          e0.collidedWithCircle(e1);
                      } else if (e0.shape == ShapeCircle && e1.shape == ShapeLine) {
                          e0.collidedWithLine(e1);
                      } else if (e0.shape == ShapeLine && e1.shape == ShapeCircle) {
                          e1.collidedWithLine(e0);
                      } else if (e0.shape == ShapeCircle && e1.shape == ShapeRectangle) {
                          e0.collidedWithRect(e1);
                      } else if (e0.shape == ShapeRectangle && e1.shape == ShapeCircle) {
                          e1.collidedWithRect(e0);
                      }
                  }
              }
          }
      }

    </script>
  </head>
  <header><a href="{{ url_for('index')}}">ホーム</a></header>
  <body onload="init()">
    <!-- Thanks to http://takao-suenobu.com/  & http://dova-s.jp/ -->
    <audio src="bgm.mp3" id="bgm"></audio>
    <canvas id="canvas" width="800" height="600"></canvas>
    <img id="START" src="{{ url_for('static', filename='../static/images/VegetableMarch/start.png') }}" onclick="go()">
    <img id="fruitbg" src="{{ url_for('static', filename='../static/images/VegetableMarch/bgm.mp3') }}" style="display: none">
    <img id="fruit0" src="{{ url_for('static', filename='../static/images/VegetableMarch/fruit0.png') }}" style="display: none">
    <img id="fruit1" src="{{ url_for('static', filename='../static/images/VegetableMarch/fruit1.png') }}" style="display: none">
    <img id="fruit2" src="{{ url_for('static', filename='../static/images/VegetableMarch/fruit2.png') }}" style="display: none">
    <img id="fruit3" src="{{ url_for('static', filename='../static/images/VegetableMarch/fruit3.png') }}" style="display: none">
    <img id="fruit4" src="{{ url_for('static', filename='../static/images/VegetableMarch/fruit4.png') }}" style="display: none">
  </body>
</html>
